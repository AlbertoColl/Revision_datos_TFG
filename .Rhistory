# Eliminamos filas que contengan NAs
datos <- drop_na(datos)
# Obtencion de variables dummy a partir del sexo
datos <- datos %>% mutate(sexo_MALE = ifelse(sex == "male", T, F)) %>%
select(-sex)
# Escalo las variables numericas y las nuevas variables dummies, omito la variable sexo
datos_scl <- scale(datos[2:6])
# Matriz de distancias
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
datos$ac1 <- cutree(ac1, k = 4) # aqui guardar en el dataset resultados del ac1
# pca
cp_cor <- cor(datos[,2:6])
det(cp_cor)
library(MVN)
mvn(datos[,2:6], mvnTest = "mardia") # no hay normalidad
KMO(cp_cor)
summary(cp)
cp$sdev
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(2, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(4, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
datos$ac1 <- cutree(ac1, k = 5) # aqui guardar en el dataset resultados del ac1
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(5, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
datos$ac1 <- cutree(ac1, k = 6) # aqui guardar en el dataset resultados del ac1
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(5, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(6, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(palmerpenguins)
library(factoextra)
library(psych)
library(patchwork)
library(viridis)
rect.hclust(ac1, 5)
datos_scl <- scale(datos[2:6])
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
rect.hclust(ac1, 5)
datos$ac1 <- cutree(ac1, k = 5)
View(datos)
datos[,283]
datos[283]
datos[283,]
datos_scl[283,]
datos_scl[-283,]
datos_scl <- datos_scl[-283,]
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
rect.hclust(ac1, 3)
datos$ac1 <- cutree(ac1, k = 3) # aqui guardar en el dataset resultados del ac1
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
rect.hclust(ac1, 3)
datos$ac1 <- cutree(ac1, k = 3) # aqui guardar en el dataset resultados del ac1
datos_scl <- scale(datos[-283,2:6])
datos_scl <- datos_scl[-283,]
# Matriz de distancias
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
rect.hclust(ac1, 3)
datos$ac1 <- cutree(ac1, k = 3) # aqui guardar en el dataset resultados del ac1
datos_scl <- scale(datos[,2:6])
datos <- select(penguins, species, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, sex)
boxplot(datos[2:5]) # No parece que haya datos anómalos a simple vista
# Transformacion de la variable sexo en factor
datos$sex <- as.factor(datos$sex)
summary(datos$sex)
# Eliminamos filas que contengan NAs
datos <- drop_na(datos)
datos <- datos %>% mutate(sexo_MALE = ifelse(sex == "male", T, F)) %>%
select(-sex)
datos_scl <- scale(datos[,2:6])
# Matriz de distancias
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
# Quitamos dato 283 que no agrupa bien
datos <- datos[-283,]
datos_scl <- scale(datos[,2:6])
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
rect.hclust(ac1, 3)
datos$ac1 <- cutree(ac1, k = 3) # aqui guardar en el dataset resultados del ac1
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(3, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
# pca
cp_cor <- cor(datos[,2:6])
det(cp_cor)
library(MVN)
mvn(datos[,2:6], mvnTest = "mardia") # no hay normalidad
KMO(cp_cor)
cp <- princomp(datos[2:6], cor=TRUE)
summary(cp)
cp$sdev
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(3, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
# Quitamos dato 283 que no agrupa bien
datos <- datos[-283,]
datos_scl <- scale(datos[,2:6])
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
rect.hclust(ac1, 3)
datos$ac1 <- cutree(ac1, k = 3)
fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
# Segun este método, deberiamos escoger 4 clusters
set.seed(999)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 4)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
# Quitamos dato 283 que no agrupa bien
datos <- datos[-283,]
datos_scl <- scale(datos[,2:6])
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
rect.hclust(ac1, 3)
datos$ac1 <- cutree(ac1, k = 3)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(3 begin = 0.35, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
# Quitamos dato 283 que no agrupa bien
datos <- datos[-283,]
datos_scl <- scale(datos[,2:6])
datos <- select(penguins, species, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, sex)
### Exploración y limpieza ----
boxplot(datos[2:5]) # No parece que haya datos anómalos a simple vista
# Transformacion de la variable sexo en factor
datos$sex <- as.factor(datos$sex)
summary(datos$sex)
# Eliminamos filas que contengan NAs
datos <- drop_na(datos)
# Obtencion de variables dummy a partir del sexo
datos <- datos %>% mutate(sexo_MALE = ifelse(sex == "male", T, F)) %>%
select(-sex)
### Clustering jerarquico ----
# Escalo las variables numericas y las nuevas variables dummies, omito la variable sexo
datos_scl <- scale(datos[,2:6])
# Matriz de distancias
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
# Quitamos dato 283 que no agrupa bien
datos <- datos[-283,]
datos_scl <- scale(datos[,2:6])
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
rect.hclust(ac1, 6)
datos$ac1 <- cutree(ac1, k = 6) # aqui guardar en el dataset resultados del ac1
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(6, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
p_scree <- fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
head(penguins)
datos <- select(penguins, species, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, sex)
boxplot(datos[2:5]) # No parece que haya datos anómalos a simple vista
# Transformacion de la variable sexo en factor
datos$sex <- as.factor(datos$sex)
summary(datos$sex)
# Eliminamos filas que contengan NAs
datos <- drop_na(datos)
datos <- datos %>% mutate(sexo_MALE = ifelse(sex == "male", T, F)) %>%
select(-sex)
datos_scl <- scale(datos[,2:6])
# Matriz de distancias
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
# Quitamos dato 283 que no agrupa bien
datos <- datos[-283,]
datos_scl <- scale(datos[,2:6])
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
rect.hclust(ac1, 3)
datos$ac1 <- cutree(ac1, k = 3) # aqui guardar en el dataset resultados del ac1
fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
# Segun este método, deberiamos escoger 4 clusters
set.seed(999)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 4)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
datos_scl <- scale(datos[,2:6])
# Matriz de distancias
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
6
6
fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
# Segun este método, deberiamos escoger 4 clusters
set.seed(999)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 5)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 6)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 5)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 3)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 4)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
datos <- select(penguins, species, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, sex)
### Exploración y limpieza ----
boxplot(datos[2:5]) # No parece que haya datos anómalos a simple vista
# Transformacion de la variable sexo en factor
datos$sex <- as.factor(datos$sex)
summary(datos$sex)
# Eliminamos filas que contengan NAs
datos <- drop_na(datos)
# Obtencion de variables dummy a partir del sexo
datos <- datos %>% mutate(sexo_MALE = ifelse(sex == "male", T, F)) %>%
select(-sex)
### Clustering jerarquico ----
# Escalo las variables numericas y las nuevas variables dummies, omito la variable sexo
fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
# Segun este método, deberiamos escoger 4 clusters
set.seed(999)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 4)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 5)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 6)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
datos_scl <- scale(datos[,2:6])
# Matriz de distancias
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
# Quitamos dato 283 que no agrupa bien
datos <- datos[-283,]
datos_scl <- scale(datos[,2:6])
distancia <- dist(datos_scl)
ac1 <- hclust(distancia)
plot(ac1, main = "Clúster sobre especies de pingüinos", cex = 0.7)
rect.hclust(ac1, 3)
datos$ac1 <- cutree(ac1, k = 3) # aqui guardar en el dataset resultados del ac1
fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
# Segun este método, deberiamos escoger 4 clusters
set.seed(999)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 4)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 3)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 5)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 6)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 4)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 5)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
(p_ac2 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac2),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(5, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering no jerárquico (k-means)"))
(p_ac2 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac2),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(5, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering no jerárquico (k-means)"))
datos$ac2 <- ac2$cluster
(p_ac2 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac2),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(5, begin = 0.25, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering no jerárquico (k-means)"))
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 6)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
# Segun este método, deberiamos escoger 4 clusters
set.seed(999)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 6)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
# Segun este método, deberiamos escoger 4 clusters
set.seed(99)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 6)
ac2
fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
(p_ac2 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac2),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(5, begin = 0.35, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering no jerárquico (k-means)"))
(p_sp <- fviz_pca_biplot(cp, habillage=as.factor(datos$species),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(3, alpha = 0.6, begin = 0.1, end = 0.7, option = "G"), col.var = "mediumvioletred") + labs(title ="Especies de pingüinos"))
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(3, begin = 0.35, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
(p_ac2 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac2),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(5, begin = 0.35, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering no jerárquico (k-means)"))
p_scree <- fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
set.seed(999)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 5)
p_cluster <- fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
datos$ac2 <- ac2$cluster
(p_scree | p_cluster) & theme_minimal()
(p_sp <- fviz_pca_biplot(cp, habillage=as.factor(datos$species),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(3, alpha = 0.6, begin = 0.1, end = 0.7, option = "G"), col.var = "mediumvioletred") + labs(title ="Especies de pingüinos"))
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(3, begin = 0.35, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
(p_ac2 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac2),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(5, begin = 0.35, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering no jerárquico (k-means)"))
p_scree <- fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
set.seed(999)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 6)
p_cluster <- fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
datos$ac2 <- ac2$cluster
(p_scree | p_cluster) & theme_minimal()
p_scree <- fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
set.seed(999)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 6)
p_cluster <- fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
datos$ac2 <- ac2$cluster
(p_scree | p_cluster) & theme_minimal()
p_scree <- fviz_nbclust(scale(datos[2:6]), kmeans, "wss")
set.seed(99)
ac2 <- kmeans(as.matrix(scale(datos[2:6])), 6)
p_cluster <- fviz_cluster(ac2, scale(datos[2:6]), ellipse.type = "norm")
datos$ac2 <- ac2$cluster
(p_scree | p_cluster) & theme_minimal()
(p_sp <- fviz_pca_biplot(cp, habillage=as.factor(datos$species),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(3, alpha = 0.6, begin = 0.1, end = 0.7, option = "G"), col.var = "mediumvioletred") + labs(title ="Especies de pingüinos"))
(p_ac1 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac1),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(3, begin = 0.35, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering jerárquico"))
(p_ac2 <- fviz_pca_biplot(cp, habillage=as.factor(datos$ac2),
addEllipses=TRUE, ellipse.level=0.95, palette = viridis(6, begin = 0.35, end = 0.8), col.var = "mediumvioletred") + labs(title ="Clustering no jerárquico (k-means)"))
### SETUP ----
library(tidyverse)
library(multcompView)
library(car)
library(rstatix)
### SETUP ----
library(tidyverse)
library(multcompView)
library(car)
library(rstatix)
setwd("C:/Users/Usuario/Documents/GitHub/Revision_datos_TFG") # Lab
source(file = "./scripts septiembre 2024-2025/0_data_lab.R")
source(file = "./scripts septiembre 2024-2025/1_funciones_graficas.R")
setwd("C:/Users/Usuario/Documents/GitHub/Revision_datos_TFG") # Lab
source(file = "./scripts septiembre 2024-2025/0_data_lab.R")
source(file = "./scripts septiembre 2024-2025/1_funciones_graficas.R")
data_1 <- filter(datos, cultivo == "wild")
### Exploracion ----
summ <- data_1 %>%
group_by(playa) %>%
get_summary_stats(G6PDH_t,type = "mean_se")
ggplot(summ, aes(x = playa)) +
geom_col(aes(y = mean, fill = playa, color = playa), alpha = 0.6) +
geom_errorbar(aes(ymax = mean+se, ymin = mean-se, color = playa), linewidth = 1, width = 0.4) +
labs(title = "Actividad G6PDH_t por playa") +
theme(legend.position = "none")
ggplot(data_1, aes(x = playa, y = GPx_p)) +
geom_boxplot(aes(fill = playa, color = playa), alpha = 0.3, linewidth = 1) +
geom_point(aes(color = playa), position = position_jitterdodge(), size = 2) +
labs(title = "Actividad GPx_p por playa") +
theme(legend.position = "none")
data_1$G6PDH_t[12] <- NA # Resuelve la normalidad de residuos
# Hacemos anova de 1 via si cumple asunciones
modelos <- lapply(colnames(data_1[c(5:24)]), function(x){
aov(formula = as.formula(paste0(x, " ~ playa")), data_1)})
# Protocolo para hacer multiples anovas con rstatix
modelos <- lapply(colnames(data_1[c(5:24)]), function(x){
anova_test(formula = as.formula(paste0(x, " ~ playa")), data_1)})
(anova_results <- reduce(modelos, full_join) %>%
add_column(.before = 1, variable = colnames(data_1[c(5:24)])) %>%
adjust_pvalue(method = "BH"))
# Test de Levene se puede computar igual
modelos_levene <- lapply(colnames(data_1[c(5:24)]), function(x){
levene_test(formula = as.formula(paste0(x, " ~ playa")), data_1)})
(levene_results <- reduce(modelos_levene, full_join) %>%
add_column(.before = 1, variable = colnames(data_1[c(5:24)])))
modelos_shapiro <- lapply(data_1[c(5:24)], function(x){
shapiro_test(x, data_1)})
(shapiro_results <- reduce(modelos_shapiro, full_join) %>%
add_column(.before = 1, parametro = colnames(data_1[c(5:24)])))
# En laboratorio
setwd("C:/Users/Usuario/Documents/GitHub/Revision_datos_TFG") # Lab
source(file = "./scripts septiembre 2024-2025/0_data_lab.R")
source(file = "./scripts septiembre 2024-2025/1_funciones_graficas.R")
# Filtrar: solo anemonas cultivadas
data_2 <- filter(datos, cultivo == "cultured")
ggplot(data_2, aes(y = CAT_t)) +
geom_boxplot(aes(x = tiempo:corte, color = tiempo:corte), alpha = 0) +
geom_point(aes(x = tiempo:corte, color = tiempo:corte), alpha = 1, size = 2)
View(data_2)
# Ajuste de modelos ANOVA con rstatix
modelos <- lapply(colnames(data_2[c(5:24)]), function(x){
anova_test(formula = as.formula(paste0(x, " ~ corte * tiempo")), data_2)})
(anova_results <- reduce(modelos, full_join) %>%
add_column(.before = 1, variable = colnames(data_2[c(5:24)])) %>%
adjust_pvalue(method = "BH"))
modelos
reduce(modelos,full_join)
colnames(data_2[c(5:24)])
colnames(data_2[c(5:24)])*3
rep(colnames(data_2[c(5:24)])*3, each = 3)
rep(colnames(data_2[c(5:24)]), each = 3)
(anova_results <- reduce(modelos, full_join) %>%
add_column(.before = 1, variable = rep(colnames(data_2[c(5:24)]), each = 3)) %>%
adjust_pvalue(method = "BH"))
(anova_results <- reduce(modelos, full_join) %>%
add_column(.before = 1, variable = rep(colnames(data_2[c(5:24)]), each = 3)) %>%
adjust_pvalue(method = "BH"))
# Test de Levene se puede computar igual
modelos_levene <- lapply(colnames(data_1[c(5:24)]), function(x){
levene_test(formula = as.formula(paste0(x, " ~ playa")), data_1)})
(levene_results <- reduce(modelos_levene, full_join) %>%
add_column(.before = 1, variable = rep(colnames(data_2[c(5:24)]),each = 3)))
# Test de Levene se puede computar igual
modelos_levene <- lapply(colnames(data_2[c(5:24)]), function(x){
levene_test(formula = as.formula(paste0(x, " ~ corte * tiempo")), data_2)})
(levene_results <- reduce(modelos_levene, full_join) %>%
add_column(.before = 1, variable = rep(colnames(data_2[c(5:24)]),each = 3)))
(levene_results <- reduce(modelos_levene, full_join) %>%
add_column(.before = 1, variable = colnames(data_1[c(5:24)])))
(levene_results <- reduce(modelos_levene, full_join) %>%
add_column(.before = 1, variable = colnames(data_2[c(5:24)])))
# Test de Levene y Shapiro se pueden computar igual
modelos_levene <- lapply(colnames(data_2[c(5:24)]), function(x){
levene_test(formula = as.formula(paste0(x, " ~ corte * tiempo")), data_2)})
modelos_levene
modelos_shapiro <- lapply(data_2[c(5:24)], function(x){
shapiro_test(x, data_2)})
(shapiro_results <- reduce(modelos_shapiro, full_join) %>%
add_column(.before = 1, parametro = colnames(data_2[c(5:24)])))
levene_results
levene_results
shapiro_results
ggplot(data_2, aes(y = CAT_t)) +
geom_boxplot(aes(x = tiempo:corte, color = tiempo:corte), alpha = 0) +
geom_point(aes(x = tiempo:corte, color = tiempo:corte), alpha = 1, size = 2)
ggplot(data_2, aes(y = GPx_p)) +
geom_boxplot(aes(x = tiempo:corte, color = tiempo:corte), alpha = 0) +
geom_point(aes(x = tiempo:corte, color = tiempo:corte), alpha = 1, size = 2)
data_2$GPx_p[9]
ggplot(data_2, aes(y = GST_t)) +
geom_boxplot(aes(x = tiempo:corte, color = tiempo:corte), alpha = 0) +
geom_point(aes(x = tiempo:corte, color = tiempo:corte), alpha = 1, size = 2)
data_2$GST_t[9]
data_2$GST_t[7]
ggplot(data_2, aes(y = DTD_t)) +
geom_boxplot(aes(x = tiempo:corte, color = tiempo:corte), alpha = 0) +
geom_point(aes(x = tiempo:corte, color = tiempo:corte), alpha = 1, size = 2)
ggplot(data_2, aes(y = G6PDH_p)) +
geom_boxplot(aes(x = tiempo:corte, color = tiempo:corte), alpha = 0) +
geom_point(aes(x = tiempo:corte, color = tiempo:corte), alpha = 1, size = 2)
data_2$G6PDH[22]
data_2$G6PDH_p[22]
ggplot(data_2, aes(y = G6PDH_t)) +
geom_boxplot(aes(x = tiempo:corte, color = tiempo:corte), alpha = 0) +
geom_point(aes(x = tiempo:corte, color = tiempo:corte), alpha = 1, size = 2)
data_2$GPx_p[9] <- NA # posiblemente afecta a normalidad de residuos
data_2$GST_t[7] <- NA
data_2$GST_t[9] <- NA # comprobar
data_2$G6PDH_p[22] <- NA # comprobar
data_2$GPx_p[9] <- NA # posiblemente afecta a normalidad de residuos
data_2$GST_t[7] <- NA
data_2$GST_t[9] <- NA # comprobar
data_2$G6PDH_p[22] <- NA # comprobar
# Ajuste de modelos ANOVA con rstatix
modelos <- lapply(colnames(data_2[c(5:24)]), function(x){
anova_test(formula = as.formula(paste0(x, " ~ corte * tiempo")), data_2)})
(anova_results <- reduce(modelos, full_join) %>%
add_column(.before = 1, variable = rep(colnames(data_2[c(5:24)]), each = 3)) %>%
adjust_pvalue(method = "BH"))
# Test de Levene y Shapiro se pueden computar igual
modelos_levene <- lapply(colnames(data_2[c(5:24)]), function(x){
levene_test(formula = as.formula(paste0(x, " ~ corte * tiempo")), data_2)})
(levene_results <- reduce(modelos_levene, full_join) %>%
add_column(.before = 1, variable = colnames(data_2[c(5:24)])))
modelos_shapiro <- lapply(data_2[c(5:24)], function(x){
shapiro_test(x, data_2)})
(shapiro_results <- reduce(modelos_shapiro, full_join) %>%
add_column(.before = 1, parametro = colnames(data_2[c(5:24)])))
ggplot(data_2, aes(y = G6PDH_p)) +
geom_boxplot(aes(x = tiempo:corte, color = tiempo:corte), alpha = 0) +
geom_point(aes(x = tiempo:corte, color = tiempo:corte), alpha = 1, size = 2)
### SETUP y filtrado de datos ----
# En portatil (arreglar)
# setwd("D:/collf/Documents/GitHub/Revision_datos_TFG") # Casa
#source(file = "./scripts enero24/0_data_home.R")
# En laboratorio
setwd("C:/Users/Usuario/Documents/GitHub/Revision_datos_TFG") # Lab
source(file = "./scripts septiembre 2024-2025/0_data_lab.R")
source(file = "./scripts septiembre 2024-2025/1_funciones_graficas.R")
# Filtrar: solo anemonas cultivadas
data_2 <- filter(datos, cultivo == "cultured")
modelos
residuals(modelos)
residuals(modelos[[1]])
residuals(modelos[1])
modelos[1]
View(modelos)
modelos <- lapply(colnames(data_2[c(5:24)]), function(x){
aov(formula = as.formula(paste0(x, " ~ corte * tiempo")), data_2)})
sapply(modelos, function(x){
print(x$terms[[2]])
shapiro.test(residuals(x))})
